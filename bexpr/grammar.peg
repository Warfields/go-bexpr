{
package bexpr

import (
   "strconv"
   "strings"
)

// The Parse, ParseFile and ParseReader functions will return an error that
// also satisfies this interface.
type ErrorList interface {
   Errors() []error
}

func (list errList) Errors() []error {
   return list
}

// Each error in the ErrorList returned by Parse, ParseFile and ParseReader
// will conform to this interface.
type ParserError interface {
   error
   InnerError() error
   Pos() (int, int, int)
   Expected() []string
}

func (p *parserError) InnerError() error {
   return p.Inner
}

func (p *parserError) Pos() (line, col, offset int) {
   return p.pos.line, p.pos.col, p.pos.offset
}

func (p *parserError) Expected() []string {
   return p.expected
}

}

Input <- _? expr:OrExpression _? EOF {
   return expr, nil
}

OrExpression <- left:AndExpression _ "or" _ right:AndExpression {
   return &BinaryExpr{
      Operator: BinaryOpOr,
      Left: left.(Expr),
      Right: right.(Expr),
   }, nil
} / expr:AndExpression {
   return expr, nil
}

AndExpression <- left:NotExpression _ "and" _ right:NotExpression {
   return &BinaryExpr{
      Operator: BinaryOpAnd,
      Left: left.(Expr),
      Right: right.(Expr),
   }, nil
} / expr:NotExpression {
   return expr, nil
}

NotExpression <- "not" _ expr:NotExpression {
   return &UnaryExpr{
      Operator: UnaryOpNot,
      Operand: expr.(Expr),
   }, nil
} / expr:ParenthesizedExpression {
   return expr, nil
}

ParenthesizedExpression <- "(" _? expr:OrExpression _? ")" {
   return expr, nil
} / expr:MatchExpression {
   return expr, nil
} / "(" _? OrExpression _? !")" &{
   return false, errors.New("Unmatched parentheses")
}

MatchExpression "match" <- MatchSelectorOpValue / MatchSelectorOp / MatchValueOpSelector

MatchSelectorOpValue "match" <- selector:Selector operator:(MatchEqual / MatchNotEqual) value:Value {
   return &MatchExpr{Selector: selector.(Selector), Operator: operator.(MatchOperator), Value: value.(*Value)}, nil
}

MatchSelectorOp "match" <- selector:Selector operator:(MatchIsEmpty / MatchIsNotEmpty) {
   return &MatchExpr{Selector: selector.(Selector), Operator: operator.(MatchOperator), Value: nil}, nil
}

MatchValueOpSelector "match" <- value:Value operator:(MatchIn / MatchNotIn) selector:Selector {
   return &MatchExpr{Selector: selector.(Selector), Operator: operator.(MatchOperator), Value: value.(*Value)}, nil
} / Value operator:(MatchIn / MatchNotIn) !Selector &{
   return false, errors.New("Invalid selector")
}

MatchEqual <- _? "==" _? {
   return MatchEqual, nil
}
MatchNotEqual <- _? "!=" _? {
   return MatchNotEqual, nil
}
MatchIsEmpty <- _ "is" _ "empty" {
   return MatchIsEmpty, nil
}
MatchIsNotEmpty <- _"is" _ "not" _ "empty" {
   return MatchIsNotEmpty, nil
}
MatchIn <- _ "in" _ {
   return MatchIn, nil
}
MatchNotIn <- _ "not" _ "in" _ {
   return MatchNotIn, nil
}

Selector "selector" <- first:Identifier rest:SelectorOrIndex* {
   sel := Selector{
      first.(string),
   }

   if rest != nil {
      for _, v := range rest.([]interface{}) {
        sel = append(sel, v.(string))
      }
   }
   return sel, nil
}

Identifier <- [a-zA-Z] [a-zA-Z0-9_]* {
   return string(c.text), nil
}

SelectorOrIndex <- "." ident:Identifier {
   return ident, nil
} / expr:IndexExpression {
   return expr, nil
}

IndexExpression "index" <- "[" _? lit:StringLiteral _? "]" {
   return lit, nil
} / "[" _? !StringLiteral &{
   return false, errors.New("Invalid index")
} / "[" _? StringLiteral _? !"]" &{
   return false, errors.New("Unclosed index expression")
}

Value "value" <- selector:Selector { return &Value{Raw:strings.Join(selector.(Selector), ".")}, nil }
       / i:IntLiteral { return &Value{Raw: i.(string)}, nil }
       / s:StringLiteral { return &Value{Raw: s.(string)}, nil}

IntLiteral "integer" <- "-"? [1-9][0-9]* &(_ / EOF){
   return string(c.text), nil
} / "-"? [1-9][0-9]* !(_ / EOF) &{
  return false, errors.New("Invalid integer literal")
}

StringLiteral "string" <- ('`' RawStringChar* '`' / '"' DoubleStringChar* '"') {
  return strconv.Unquote(string(c.text))
} / ('`' RawStringChar* / '"' DoubleStringChar*) EOF &{
  return false, errors.New("Unterminated string literal")
}

RawStringChar <- !'`' .
DoubleStringChar <- !'"' .

_ "whitespace" <- [ \t\r\n]+

EOF <- !.