{
// Code generated by pigeon DO NOT EDIT.

package bexpr

import (
   "strconv"
   "strings"
)
}

Input <- _? expr:OrExpression _? EOF {
   return expr, nil
}

OrExpression <- left:AndExpression _ "or" _ right:AndExpression {
   return &BinaryExpr{
      Operator: BinaryOpOr,
      Left: left.(Expr),
      Right: right.(Expr),
   }, nil
} / expr:AndExpression {
   return expr, nil
}

AndExpression <- left:NotExpression _ "and" _ right:NotExpression {
   return &BinaryExpr{
      Operator: BinaryOpAnd,
      Left: left.(Expr),
      Right: right.(Expr),
   }, nil
} / expr:NotExpression {
   return expr, nil
}

NotExpression <- "not" _ expr:NotExpression {
   return &UnaryExpr{
      Operator: UnaryOpNot,
      Operand: expr.(Expr),
   }, nil
} / expr:ParenthesizedExpression {
   return expr, nil
}

ParenthesizedExpression <- "(" _? expr:OrExpression _? ")" {
   return expr, nil
} / expr:MatchExpression {
   return expr, nil
}

MatchExpression <- selector:Selector _? "==" _? value:Value     { return &MatchExpr{Selector: selector.(Selector), Operator: MatchEqual, Value: value.(*Value)}, nil }
                 / selector:Selector _? "!=" _? value:Value     { return &MatchExpr{Selector: selector.(Selector), Operator: MatchNotEqual, Value: value.(*Value)}, nil }
                 / selector:Selector _ "is" _ "empty"           { return &MatchExpr{Selector: selector.(Selector), Operator: MatchIsEmpty, Value: nil}, nil }
                 / selector:Selector _ "is" _ "not" _ "empty"   { return &MatchExpr{Selector: selector.(Selector), Operator: MatchIsNotEmpty, Value: nil}, nil }
                 / value:Value _ "in" _ selector:Selector         { return &MatchExpr{Selector: selector.(Selector), Operator: MatchIn, Value: value.(*Value)}, nil}
                 / value:Value _ "not" _ "in" _ selector:Selector { return &MatchExpr{Selector: selector.(Selector), Operator: MatchNotIn, Value: value.(*Value)}, nil}

Selector <- first:Identifier rest:("." Identifier)* {
   sel := Selector{
      first.(string),
   }

   if rest != nil {
      for _, v := range rest.([]interface{}) {
         sel = append(sel, v.([]interface{})[1].(string))
      }
   }
   return sel, nil
}

Identifier <- [a-zA-Z] [a-zA-Z0-9_]* {
  return string(c.text), nil
}

Value <- selector:Selector { return &Value{Raw:strings.Join(selector.(Selector), ".")}, nil }
       / i:IntLiteral { return &Value{Raw: i.(string)}, nil }
       / s:StringLiteral { return &Value{Raw: s.(string)}, nil}
       / &{ return false, errors.New("Invalid Value")}

IntLiteral <- "-"? [1-9][0-9]* {
   return string(c.text), nil
}

StringLiteral <- ('`' RawStringChar* '`' / '"' DoubleStringChar* '"') {
  return strconv.Unquote(string(c.text))
} / ('`' / '"') &{ return false, errors.New("Invalid StringLiteral")}

RawStringChar <- !'`' .
DoubleStringChar <- !'"' .

_ "whitespace" <- [ \t\r\n]+

EOF <- !.